package main

import (
	"fmt"
	"io/ioutil"
	"math"
	"regexp"
	"sort"
	"strings"
)

type image struct {
	id     string
	pixels [][]int
}

func (i *image) flip() {
	newPixels := make([][]int, len(i.pixels))
	for j, row := range i.pixels {
		newPixels[j] = make([]int, len(row))
	}
	for y, row := range i.pixels {
		for x, val := range row {
			newPixels[y][len(row)-x-1] = val
		}
	}
	i.pixels = newPixels
}

func (i *image) rotate() {
	newPixels := make([][]int, len(i.pixels))
	for j, row := range i.pixels {
		newPixels[j] = make([]int, len(row))
	}
	for y, row := range i.pixels {
		for x := range row {
			newPixels[y][x] = i.pixels[len(row)-x-1][y]
		}
	}
	i.pixels = newPixels
}

const (
	up    = iota
	down  = iota
	left  = iota
	right = iota
)

func (i *image) getEdge(edge int) []int {
	if edge == up {
		return i.pixels[0]
	} else if edge == right {
		var pixels []int
		for _, row := range i.pixels {
			pixels = append(pixels, row[len(row)-1])
		}
		return pixels
	} else if edge == down {
		return i.pixels[len(i.pixels)-1]
	} else {
		var pixels []int
		for _, row := range i.pixels {
			pixels = append(pixels, row[0])
		}
		return pixels
	}
}

func (i *image) fitsIn(frame [][]image, y int, x int) bool {
	if frame[y][x].id != "" {
		//fmt.Println(i.id, "does not fits", y, x, "occupied")
		return false
	}
	locationsToCheckWith := [][3]int{}
	if y != 0 {
		locationsToCheckWith = append(locationsToCheckWith, [3]int{-1, 0, up})
	}
	if y != len(frame)-1 {
		locationsToCheckWith = append(locationsToCheckWith, [3]int{1, 0, down})
	}
	if x != 0 {
		locationsToCheckWith = append(locationsToCheckWith, [3]int{0, -1, left})
	}
	if x != len(frame[0])-1 {
		locationsToCheckWith = append(locationsToCheckWith, [3]int{0, 1, right})
	}
	/*if len(locationsToCheckWith) == 0{
		return true
	}*/

	allNeighboursEmpty := true
	for _, n := range locationsToCheckWith {
		neighbour := frame[y+n[0]][x+n[1]]
		if neighbour.id != "" {
			allNeighboursEmpty = false
			break
		}
	}
	if allNeighboursEmpty {
		return true
	}

	// For every rotation/flip
	// If it matches all neighbours, ret true
	for r := 0; r < 8; r++ {
		matches := true
		for _, n := range locationsToCheckWith {
			neighbour := frame[y+n[0]][x+n[1]]
			if neighbour.id == "" {
				continue
			}
			switch n[2] {
			case up:
				//fmt.Println("Comparing up to down")
				if !compare(i.getEdge(up), neighbour.getEdge(down)) {
					matches = false
					break
				}
			case left:
				//fmt.Println("Comparing left to right")
				if !compare(i.getEdge(left), neighbour.getEdge(right)) {
					matches = false
					break
				}
			case down:
				//fmt.Println("Comparing down to up")
				if !compare(i.getEdge(down), neighbour.getEdge(up)) {
					matches = false
					break
				}
			case right:
				//fmt.Println("Comparing right to left")
				if !compare(i.getEdge(right), neighbour.getEdge(left)) {
					matches = false
					break
				}
			}

		}
		if matches {
			//fmt.Println(i.id, "fits", y, x)
			return true
		}
		if r%4 == 0 {
			//fmt.Println("Flipping",i.id)
			i.flip()
		}
		i.rotate()
	}
	//fmt.Println(i.id, "does not fit", y, x, "default")
	return false
}

func compare(edge []int, edge2 []int) bool {
	/*fmt.Println("Comparing")
	fmt.Println(edge)
	fmt.Println(edge2)*/
	for i, v := range edge {
		if edge2[i] != v {
			//fmt.Println("FALSE")
			return false
		}
	}
	//fmt.Println("TRUE")
	return true
}

func pop(m map[string]image, key string) map[string]image {
	_, ok := m[key]
	if ok {
		delete(m, key)
	}
	return m
}

func part1(images map[string]image) int {
	// There must be a match to all frames.
	// So start with the first..
	side := int(math.Sqrt(float64(len(images))))
	frame := make([][]image, side)
	for i := 0; i < side; i++ {
		frame[i] = make([]image, side)
	}
	_, err := place(frame, images, 0)
	if err != nil {
		fmt.Println(err)
	} else {
		fmt.Println("filledFrame")
	}

	/*frame[0][0] = images["1951"]
	i := images["2311"]
	fmt.Println("2311 FITS", i.fitsIn(frame, 0,1))
	frame[0][1] = images["2311"]
	printFrame(frame)

	i = images["3079"]
	fmt.Println("3079 FITS", i.fitsIn(frame, 0,2))
	frame[0][2] = images["3079"]
	printFrame(frame)

	fmt.Println("-------------")

	i = images["2729"]
	fmt.Println("2729 FITS", i.fitsIn(frame, 1,0))
	frame[1][0] = images["2729"]

	printImage(images["2729"])
	printImage(images["1951"])*/

	return 0
}

func printImage(i image) {
	fmt.Println("--- Image", i.id, " --- ")
	for _, row := range i.pixels {
		for _, col := range row {
			fmt.Print(col, " ")
		}
		fmt.Println()
	}
	fmt.Println("--- End ---")
	fmt.Println()
}

func place(frame [][]image, images map[string]image, depth int) ([][]image, error) {
	//fmt.Println("Place - depth",depth,"..", len(images), "left to place")
	if len(images) == 1{
		printFrame(frame)
		fmt.Println("Hello!")
	}
	//printFrame(frame)
	if len(images) == 0 {
		// We filled the frame! yay
		printFrame(frame)
		return frame, nil
	}

	// Try to place i in the frame

	keys := make([]string, 0, len(images))
	for k := range images {
		keys = append(keys, k)
	}
	sort.Strings(keys)
	//fmt.Println("Left to place",keys)
	for _, id := range keys {
		i := images[id]
		if depth == 0{
			fmt.Println("Left to place",keys)
			fmt.Println("Trying to place",i.id)
		}else if depth == 1{
			fmt.Println("  Left to place",keys)
			fmt.Println("  Trying to place",i.id)
		}else if depth == 2{
			fmt.Println("    Left to place",keys)
			fmt.Println("    Trying to place",i.id)
		}else if depth == 3{
			fmt.Println("      Left to place",keys)
			fmt.Println("      Trying to place",i.id)
		}else if depth == 4{
			fmt.Println("        Left to place",keys)
			fmt.Println("        Trying to place",i.id)
		}else if depth == 5{
			fmt.Println("          Left to place",keys)
			fmt.Println("          Trying to place",i.id)
		}else if depth == 6{
			fmt.Println("            Left to place",keys)
			fmt.Println("            Trying to place",i.id)
		}
		//fmt.Println("Trying to place",i.id)
		//for j := 0; j < 8; j++ {
			// Try to place the image at locations
			for y, row := range frame {
				for x := range row {
					// Does it fit here?
					if frame[y][x].id == "" {
						//fmt.Println("Trying", i.id, "in", y, x)
						if i.fitsIn(frame, y, x) {
							// Place!
							frame[y][x] = images[id]
							//printFrame(frame)
							//fmt.Println("Trying", frame)

							// Continue to place all images, except this one
							mapCopy := make(map[string]image)
							for k, v := range images {
								if k != id {
									mapCopy[k] = v
								}
							}
							depth++
							f, err := place(frame, mapCopy, depth)
							if err != nil {
								//fmt.Println("Resetting", id, err)
								frame[y][x] = image{}
							} else {
								// hey ! This worked fine :-)
								fmt.Println("OK")
								return f, nil
							}
						}
					}
				}
			}
			/*i.rotate()
			if j % 4 == 0 {
				i.flip()
			}
		}*/
		//break
	}
	//fmt.Println(frame)
	// We tried all the images, on all locations.. Error!
	return frame, fmt.Errorf("Couldnt find the solution")
}

func printFrame(frame [][]image) {

	fmt.Println("--- Frame ---")
	for _, row := range frame {
		for _, c := range row {
			if c.id == "" {
				fmt.Print("EMPTY ")
			} else {
				fmt.Print(c.id, "  ")
			}
		}
		fmt.Println()
	}
	fmt.Println("--- End ---")
	fmt.Println()
}

//fmt.Errorf("Couldnt find the solution")
func readFile(filename string) (images map[string]image) {
	images = make(map[string]image)
	file, err := ioutil.ReadFile(filename)
	if err != nil {
		panic(err)
	}
	lines := strings.Split(string(file), "\n")
	r := regexp.MustCompile(`Tile (\d{4}):`)
	img := image{}
	for _, line := range lines {
		if len(strings.Trim(line, " ")) == 0 {

			if img.id != "" {
				images[img.id] = img //= append(images, img)
			}

		}
		matches := r.FindStringSubmatch(line)
		if len(matches) > 0 {
			img = image{}
			img.id = matches[1]
		} else {
			var bs []int
			for _, c := range line {
				p := 0
				if c == '#' {
					p = 1
				}
				bs = append(bs, p)
			}
			img.pixels = append(img.pixels, bs)
		}
	}
	return
}

func main() {
	// So far, only the edges are interesting
	fmt.Println(part1(readFile("aoc_go/2020/day20/test")))
}
