package main

import (
	"fmt"
	"io/ioutil"
	"math"
	"regexp"
	"strings"
)

type image struct {
	id     string
	pixels [][]int
}

func (i *image) flip() {
	newPixels := make([][]int, len(i.pixels))
	for j, row := range i.pixels {
		newPixels[j] = make([]int, len(row))
	}
	for y, row := range i.pixels {
		for x, val := range row {
			newPixels[y][len(row)-x-1] = val
		}
	}
	i.pixels = newPixels
}

func (i *image) rotate() {
	newPixels := make([][]int, len(i.pixels))
	for j, row := range i.pixels {
		newPixels[j] = make([]int, len(row))
	}
	for y, row := range i.pixels {
		for x := range row {
			newPixels[y][x] = i.pixels[len(row)-x-1][y]
		}
	}
	i.pixels = newPixels
}

const (
	up    = iota
	down  = iota
	left  = iota
	right = iota
)

func (i *image) getEdge(edge int) []int {
	if edge == up {
		return i.pixels[0]
	} else if edge == right {
		var pixels []int
		for _, row := range i.pixels {
			pixels = append(pixels, row[len(row)-1])
		}
		return pixels
	} else if edge == down {
		return i.pixels[len(i.pixels)-1]
	} else {
		var pixels []int
		for _, row := range i.pixels {
			pixels = append(pixels, row[0])
		}
		return pixels
	}
}

type neighbour struct {
	direction int
	matchEdge []int
}

func (i *image) fitsIn(frame [][]image, y int, x int) bool {
	// Do we have neighbours
	var neighbours []neighbour
	if y != 0 && frame[y-1][x].id != "" {
		neighbours = append(neighbours, neighbour{up, frame[y-1][x].getEdge(down)})
	}
	if y != len(frame)-1 && frame[y+1][x].id != "" {
		neighbours = append(neighbours, neighbour{down, frame[y+1][x].getEdge(up)})
	}
	if x != 0 && frame[y][x-1].id != "" {
		neighbours = append(neighbours, neighbour{left, frame[y][x-1].getEdge(right)})
	}
	if x != len(frame[0])-1 && frame[y][x+1].id != "" {
		neighbours = append(neighbours, neighbour{right, frame[y][x+1].getEdge(left)})
	}
	//fmt.Println(neighbours)

	// For each neighbour - do we fit
	fits := true
	for _, n := range neighbours {
		if !compare(i.getEdge(n.direction), n.matchEdge) {
			fits = false
			break
		}
	}

	return fits
}

func compare(edge []int, edge2 []int) bool {
	if len(edge) != len(edge2) {
		return false
	}
	//fmt.Println("compare",edge,edge2)
	for i, v := range edge {
		if edge2[i] != v {
			return false
		}
	}
	return true
}
func part1(images map[string]image) int {
	// There must be a match to all frames.
	// So start with the first..
	side := int(math.Sqrt(float64(len(images))))
	frame := make([][]image, side)
	for i := 0; i < side; i++ {
		frame[i] = make([]image, side)
	}
	_, err := place(frame, images, 0)
	if err != nil {
		fmt.Println(err)
	} else {
		fmt.Println("filledFrame")
	}

	return 0
}

func printImage(i image) {
	fmt.Println("--- Image", i.id, " --- ")
	for _, row := range i.pixels {
		for _, col := range row {
			fmt.Print(col, " ")
		}
		fmt.Println()
	}
	fmt.Println("--- End ---")
	fmt.Println()
}

func place(frame [][]image, images map[string]image, depth int) ([][]image, error) {
	if len(images) == 0 {
		// We filled the frame! yay
		printFrame(frame)
		return frame, nil
	}
	printFrame(frame)

	/*keys := make([]string, 0, len(images))
	for k := range images {
		keys = append(keys, k)
	}
	sort.Strings(keys)*/
	for id := range images {
		i := images[id]
		/*for x:=0;x<depth;x++{
			fmt.Print(" ")
		}
		fmt.Println("Trying ",i.id)*/
		for f := 0; f < 2; f++ {
			for r := 0; r < 4; r++ {
				for y, row := range frame {
					for x := range row {
						// Not already used
						if frame[y][x].id == "" {
							// Check the edges...
							if i.fitsIn(frame, y, x) {
								frame[y][x] = images[id]
								//printFrame(frame)

								mapCopy := make(map[string]image)
								for k, v := range images {
									if k != id {
										mapCopy[k] = v
									}
								}
								depth++
								f, err := place(frame, mapCopy, depth)
								if err != nil {
									//fmt.Println("Resetting",id)
									frame[y][x] = image{}
								} else {
									fmt.Println("OK")
									return f, nil
								}
							}
						}
					}
				}
			}
			i.rotate()
		}
		i.flip()
	}
	return frame, fmt.Errorf("Couldnt find the solution")
}

func printFrame(frame [][]image) {

	fmt.Println("--- Frame ---")
	for _, row := range frame {
		for _, c := range row {
			if c.id == "" {
				fmt.Print("EMPTY ")
			} else {
				fmt.Print(c.id, "  ")
			}
		}
		fmt.Println()
	}
	fmt.Println("--- End ---")
	fmt.Println()
}

func readFile(filename string) (images map[string]image) {
	images = make(map[string]image)
	file, err := ioutil.ReadFile(filename)
	if err != nil {
		panic(err)
	}
	lines := strings.Split(string(file), "\n")
	r := regexp.MustCompile(`Tile (\d{4}):`)
	img := image{}
	for _, line := range lines {
		if len(strings.Trim(line, " ")) == 0 {

			if img.id != "" {
				images[img.id] = img
			}

		}
		matches := r.FindStringSubmatch(line)
		if len(matches) > 0 {
			img = image{}
			img.id = matches[1]
		} else {
			var bs []int
			for _, c := range line {
				p := 0
				if c == '#' {
					p = 1
				}
				bs = append(bs, p)
			}
			img.pixels = append(img.pixels, bs)
		}
	}
	return
}

func main() {
	// So far, only the edges are interesting
	fmt.Println(part1(readFile("aoc_go/2020/day20/test")))
}
